# Project metrics

Monitoring metrics of a given project can sometimes be challenging. What to track, the cardinality of each tag, how to name the metrics, what should be split into a tag or kept as a metric. Building such a framework is complicated and needs some experience.

Monitoring a project development is probably a bit less complicated considering it might involve less metrics but where or how to store those metrics is something to look at seriously.

## State of the art

For open source projects, many saas online offer free tiers for monitoring things. If you want to track code coverage, you can use [codecov.io](https://codecov.io), [coveralls.io](https://coveralls.io). If you want to track complexity, you can use [codeclimate.com](https://codeclimate.com/). Those are nice because they come with some GitHub integration if you store your code there.

For closed source projects, those saas also provide paid subscriptions but it's time to warm up your credit card. Or, if your devops team has some bandwidth, you can start building a heavy machinery with your own [sonarqube](https://www.sonarsource.com/products/sonarqube/) or any similar software.

In any case, get ready for some vendor locking, unless you don't care about loosing your history.

## Other possibility

But the question is: shouldn't the metrics related to the code attached to the code itself?

We already see [some projects](https://github.com/actions/typescript-action) versioning the code coverage alongside the code. It's not perfect because the developer has to update it for each commit, or you need to introduce a CI job that updates it, but you'll end up not always being in sync.

But the idea of keeping it directly in Git is really pleasing. Anybody pulling the code has access to those metrics, you don't rely on any external service and if you want to switch from GitHub to Gitlab, it's as easy as a push.

To avoid the former issue, instead of writing those metrics with the code, we could just keep it next to it. Git provides a nice feature, that is quite underrated, called [`notes`](https://git-scm.com/docs/git-notes) that provides the ability to attach whatever textual data to a given commit reference.

## Solution implementation

That's how [`git-metrics`](https://github.com/jdrouet/git-metrics) is built.

### Basic usage

With this tool, it's possible to attach, replace or remove metrics for a given commit with a simple command

```bash
$ git-metrics add my-metric-name --tag "foo: bar" 1024.0
```

You can also show the metrics attached to a given commit

```bash
$ git metrics show <commit-sha>
my-metric-name{foo="bar"} 1024.0
```

You can even display a list of all the commits, or in a given commit range

```bash
$ git metrics diff HEAD~2..HEAD
- my-metric-name{foo="bar"} 512.0
+ my-metric-name{foo="bar"} 1024.0 (+200.00 %)
```

That's a first good step, but we can do way more than that.

### Extra features

#### Budget management

Tracking metrics is a good thing, but we should be doing that for a reason: improving the codebase or the project.

One way to improve that would be to block commits where generated metrics don't match some rules. That's a way external services already use.

With `git-metrics`, you can configure some rules by simply adding a `.git-metrics.toml` configuration file to the root of your repository.

```toml
# fails when increase size is above 10%
[[metrics.binary-size.rules]]
type = "max-increase"
ratio = 0.1

# fails when the size increases by more that 1MB
[[metrics.binary-size.rules]]
type = "max-increase"
value = 1048576.0

# fails when binary size is more than 10MB
[[metrics.binary-size.rules]]
type = "max"
value = 10485760.0

# fails when the code coverage goes below 80%
[[metrics."coverage.lines.percentage".rules]]
type = "min"
value = 0.8

# fails when the code coverage decreases of more than 5%
[[metrics."coverage.lines.percentage".rules]]
type = "max-decrease"
ratio = 0.05
```

And next time you call `git-metrics check` from your CI, after adding your metrics, you will know if you meet your specified budget.

#### Importing from other file formats

Importing metrics by just using a `add` command could be a bit cumbersome. Especially when you want to add some derivated metrics.

For example, after computing a code coverage, you will probably end up with a `lcov` file. But this file doesn't clearly state the code coverage of your codebase. You have to compute it based on it. This is something standard that `git-metrics` should be able to deal with.

```bash
$ git-metrics import lcov ./lcov.info
```

And this should add the summary metrics you were looking for like `coverage.lines.count`, `coverage.functions.hit` or `coverage.branches.percentage`.

As of today, `git-metrics` only supports `lcov` files but the support will be expended when people will start using it and asking for more.

## Conclusion

`git-metrics` is still really early stage, but already provides a good set of commands that can be used to do the basics: you can track metrics, create a budget and block contributions if they don't satisfy your budget, without leaving your git repository.

Like the saas solutions mentioned above, `git-metrics` comes with a set of [GitHub actions](https://github.com/jdrouet/action-git-metrics) to install, track and check your metrics. The equivalent for Gitlab should be coming soon.
