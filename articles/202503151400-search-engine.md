# Building a Search Engine from Scratch in Rust

In January of this year, I was hired by a company dedicated to keeping client data private. To achieve this, they encrypt as much data as possible, making efficient search functionality a significant challenge.

## The Challenge

The core issue was simple: how do you allow users to search through their encrypted data while ensuring it remains private? Standard search solutions were not an option, as they typically require decrypting data on the server—something we couldn’t allow.

## Key Requirements

- **Privacy-first indexing** – Once data is indexed, it should remain encrypted on disk, preventing content extraction through index analysis.
- **On-device search** – Since decrypting data on the server was not viable, and homomorphic search is not yet practical, all indexing and searching had to happen directly on the user's device.
- **Minimal resource footprint** – The search engine had to work efficiently across a wide range of devices, from low-end Android phones to high-end MacBooks, optimizing CPU, memory, and binary size.
- **Cross-platform compatibility** – It needed to run seamlessly in browsers, mobile apps, and desktop applications.
- **Network-efficient synchronization** – To avoid redundant indexing, devices had to share indexes over the network, even under poor connection conditions. This required implementing sharded indexes to sync only updated segments.

## Why Existing Solutions Didn't Work

- **Meilisearch, Elasticsearch** – Store data in plaintext on the server, violating our privacy constraints.
- **Tantivy** – Relies heavily on threads, making it incompatible with browsers. Removing threading would require a major rewrite, which wasn’t practical.
- **SQLite + SQLCipher** – Lacked sharding support, resulted in a bloated binary, and posed storage challenges in a browser environment.

With no suitable off-the-shelf solution, I decided to build a custom search engine from scratch—within a tight 2.5-month deadline.
